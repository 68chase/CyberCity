<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Desktop Fly + Grab</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js';

let scene, renderer;
let camera, cameraRig;
let raycaster;
const grabState = { object: null };
const objects = [];
const MOVE_SPEED = 0.1;
const VERT_SPEED = 0.1;
const keys = { w:false, a:false, s:false, d:false, q:false, e:false };
let mouseDown=false;
let prevMouseX=0, prevMouseY=0;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  cameraRig = new THREE.Group();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  cameraRig.add(camera);
  scene.add(cameraRig);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Light
  const hemi = new THREE.HemisphereLight(0xffffff,0x222222,1);
  hemi.position.set(0,20,0);
  scene.add(hemi);

  // Grid
  const grid = new THREE.GridHelper(4000, 800, 0x00ff00, 0x004400);
  grid.material.transparent = true;
  grid.material.opacity = 0.25;
  scene.add(grid);

  // Cubes
  const cubeGeo = new THREE.BoxGeometry(0.3,0.3,0.3);
  for(let i=0;i<3;i++){
    const cube=new THREE.Mesh(cubeGeo,new THREE.MeshStandardMaterial({color:0x00ffcc}));
    cube.position.set((Math.random()*2-1)*1.5,1.4+Math.random()*0.6,-1.5-i);
    scene.add(cube); objects.push(cube);
  }

  // Spheres
  const sphereGeo = new THREE.SphereGeometry(0.2,32,32);
  for(let i=0;i<3;i++){
    const sphere=new THREE.Mesh(sphereGeo,new THREE.MeshStandardMaterial({color:0xff6600}));
    sphere.position.set((Math.random()*2-1)*1.5,1.4+Math.random()*0.6,-2.5-i);
    scene.add(sphere); objects.push(sphere);
  }

  // Panels
  const panelGeo = new THREE.PlaneGeometry(0.7,0.35);
  for(let i=0;i<3;i++){
    const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=256;
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='#001100'; ctx.fillRect(0,0,512,256);
    ctx.fillStyle='#00ff00'; ctx.font='28px monospace';
    ctx.fillText(`DATA PANEL ${i+1}`,24,56);
    ctx.font='20px monospace';
    const lines = [`SEQ: ${Math.floor(Math.random()*1e6).toString().padStart(6,'0')}`,
                   `TS : ${new Date().toISOString().slice(11,19)}`,
                   `VAL: ${(Math.random()*100).toFixed(3)}`];
    lines.forEach((t,idx)=>ctx.fillText(t,24,110+idx*36));
    const texture=new THREE.CanvasTexture(canvas);
    const mat=new THREE.MeshBasicMaterial({map:texture,side:THREE.DoubleSide,transparent:true});
    const panel=new THREE.Mesh(panelGeo,mat);
    panel.position.set((Math.random()*2-1)*1.5,1.6+Math.random()*0.5,-3.5-i);
    panel.rotation.y=(Math.random()-0.5)*0.6;
    scene.add(panel); objects.push(panel);
  }

  raycaster = new THREE.Raycaster();

  // Mouse + keyboard
  window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
  window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
  document.addEventListener('mousedown', e=>{mouseDown=true; prevMouseX=e.clientX; prevMouseY=e.clientY;});
  document.addEventListener('mouseup', ()=>{mouseDown=false;});
  document.addEventListener('mousemove', e=>{
    if(mouseDown){
      const dx = (e.clientX-prevMouseX)/200;
      const dy = (e.clientY-prevMouseY)/200;
      cameraRig.rotation.y -= dx;
      camera.rotation.x -= dy;
      camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      prevMouseX = e.clientX; prevMouseY = e.clientY;
    }
  });

  window.addEventListener('resize', onWindowResize);
}

// --- Grabbing with mouse click ---
document.addEventListener('click', ()=>{
  const mouse = new THREE.Vector2(0,0); // center of screen
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(objects,false);
  if(hits.length>0){
    const picked = hits[0].object;
    if(grabState.object){
      scene.attach(grabState.object);
      grabState.object = null;
    } else {
      cameraRig.attach(picked);
      grabState.object = picked;
    }
  }
});

// --- Movement ---
function handleMovement(){
  let dir = new THREE.Vector3();
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(cameraRig.quaternion).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(cameraRig.quaternion).normalize();

  if(keys.w) dir.addScaledVector(fwd, MOVE_SPEED);
  if(keys.s) dir.addScaledVector(fwd, -MOVE_SPEED);
  if(keys.a) dir.addScaledVector(right, -MOVE_SPEED);
  if(keys.d) dir.addScaledVector(right, MOVE_SPEED);
  if(keys.q) dir.y += VERT_SPEED;
  if(keys.e) dir.y -= VERT_SPEED;

  cameraRig.position.add(dir);
}

// --- Boilerplate ---
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function animate(){
  handleMovement();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
</script>
</body>
</html>
